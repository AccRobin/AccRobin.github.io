# 搜索

---
## 深度优先搜索（DFS）
一种用于遍历或搜索树或图的算法

- 深度优先：每次都尝试向更深的节点走
- 特征：递归调用自身 & 保证每个点只访问一次
- 复杂度：总状态数（点数）+ 总转移数（边数）

--

## 递归实例：斐波那契数
> 给出斐波那契数列第 $n$ 项 $f(n)$ 的定义：
> `$$
f(n)=\begin{cases}
1 & n=1,2\\
f(n-1)+f(n-2) & n\ge 3
\end{cases}
> $$`
> 输入 $n$，求 $f(n)$

- 数列的后项无法直接求出，而是依赖于前项
- 通俗的递归：函数自己调用自己

```cpp
int f(int n) {
    if (n == 1 || n == 2) return 1;
    return f(n - 1) + f(n - 2);
}
```
--

## DFS 实例 1：输出全排列

> 输入正整数 $n$，按字典序从小到大输出所有长度为 $n$ 的排列

画出“递归树结构”

```cpp
void dfs(int d) {
    if (d == n + 1) {
        for (int i = 1; i <= n; ++i) cout << a[i] << ' ';
        return ;
    }
    for (int i = 1; i <= n; ++i) {
        if (vis[i] == 0) {
            a[d] = i, vis[i] = 1;
            dfs(d + 1);
            vis[i] = 0;
        }
    }
}
```

--

## DFS 实例 2：八皇后问题

> 输入正整数 $n$，输出 $n\times n$ 的棋盘上至多放多少个互不攻击的皇后

