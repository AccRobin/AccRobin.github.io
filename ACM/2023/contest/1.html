<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    
    <link rel="stylesheet" href="https://accrobin.github.io/additional_files/reveal/reveal.css">
    <link rel="stylesheet" href="https://accrobin.github.io/additional_files/reveal/plugin/highlight/monokai.css">
    <link rel="stylesheet" href="https://accrobin.github.io/additional_files/reveal/theme/white.css" id="theme">    
    
    <title>训练赛 I 题目讲解</title>
</head>

<body>
    <div class="reveal">
        <div class="slides">
            <section data-markdown data-separator-vertical="@@"><script type="text/template">
                # 训练赛 I 题目讲解

@@


## 题目综评
- 签到题：A
- 基础题：B F
- 中档题：E G
- 没什么人做的题：C D

@@

## A - rect-angle
- 题目描述：
    - 平面直角坐标系上有一个矩形，它的四条边都平行于 $x$ 或 $y$ 轴，并且它的面积不为零
    - 给出这个矩形的三个顶点的坐标，问另一个顶点的坐标
- 思路：
    - 简单的分类讨论，因为矩形是平行于坐标轴的，且面积不为零，则有 $x_1,x_2,x_3,x_4$ 与 $y_1,y_2,y_3,y_4$ 都满足成对相等

@@

## B - ab-string
- 题目描述:
    - 给一个长度为 $n$ ，仅由字符'a' 'b'构成的字符串，定义一个子串为“最优子串”，当且仅当这个子串的所有字符相同
    - 我们可以对这个字符串进行不超过 $k$ 次操作，问我们能够得到的最长的“最优子串”的长度
- 思路：
    - 有一个简单、显然的性质：当 $[l,r]$ 子串满足“最优子串”时，$[l+1,r]$ 子串也满足“最优子串”，也就是说，最优子串满足单调性
    - 我们可以考虑利用“滑动窗口”的思想来解决这个问题：
        - 对每个 $l$，都有一个最大的 $r$，使得 $[l,r]$ 子串是 $k$ 次操作内从l位置开始能得到的最长的“最优子串”
        - 使 $l$ 单增，并重新调整 $r$ 使得满足题意

@@

## F - buying-item
- 题目描述：
    - 商店内有 $n$ 件商品，第 $i$ 件商品价格为 $A_i$ 元
    - 面值为 $X$ 的优惠券有 $K$ 张，注意，一张优惠券只能给一个商品用，不能拆开，商品的价格使用优惠券后最低为 $0$ 元
    - 请求出买下所有商品的最少花费
- 思路：
    - 优惠券的实际优惠总价格越高，则买下商品的总花费就最少，目的是减少优惠券的浪费
    - 按照贪心的思路，先将能完整使用优惠券的部分商品，使用多次优惠券（直到商品价格低于优惠券的面值）
    - 如果有剩余的优惠券，这时我们可以发现所有商品在使用过一些优惠券的基础上，价格都是小于优惠券面值的，这时候我们按照商品价值从大到小排序，优先对价格更高的商品使用优惠券


@@

## E - xor-road
- 题目描述：
    - 给定一个 $n \times m$ 的矩形网格，单元格 $(i,j)$ 内有一个数 $a_{i,j}$ 
    - 请统计，从 $(1,1)$ 到 $(n,m)$ 的所有路径中，路径异或和为 $k$ 的个数
- 思路：
    - 直接搜索，时间复杂度 $O(2^{m+n-2})$ ，$n,m$ 的数据规模都是20，这样的时间复杂度是难以通过时间限制的
    - 折半搜索（Meet In The Middle）：
        - 从起点和终点分别进行规模为原来一半的搜索，并在所有交点处合并计算结果
        - 该题目计算内容为异或和，异或运算具有结合律和交换律，可以倒序搜索与合并运算，因此适用折半搜索
        - 折半搜索的时间复杂度为 $O(2^{\frac{m+n-2}{2}}+合并的时间复杂度)$，因此可以通过此题

@@

## G - virus-spread
- 题目描述：
    - 给定一棵树，根节点为 $1$，每个时刻有两种操作可以选择：
        - 选择一个节点，该节点的值翻倍。
        - 选择一个节点，使其均匀地将其值分给其所有的儿子。
    - 问最少经过多少次操作可以将所有节点的值都 $\geq 1$
- 思路：
    - 考虑贪心策略：对于从根节点开始dfs的每个节点，如果不够分，则翻倍直到够分给所有儿子节点
    - 贪心的证明：最优策略肯定不会走回头路，即节点 $i$ 由 $i$ 的祖先转移来，且由父亲节点翻倍的 $dis$ 消耗最小，故由父亲节点翻倍转移得到是最优的

@@

## C - edge-direction
- 题目描述：
    - 给定一个图，包含一些有向边和无向边，请给这些无向边确定方向变为有向边，使得变换后的图无环
- 思路：
    - 我们将原图去掉无向边得到一个新图，对这个新图进行讨论
        - 如果该图存在环，则原图无向边不管如何更改方向都会存在环，故输出 $NO$
        - 如果该图无环，则该图是一个DAG，我们对其进行拓扑排序，对原图的每一条无向边，我们将方向定为由拓扑序较小的连至拓扑序较大的，则一定不会出现环

@@

## D - hex-gon
- 题目描述：
    - 给定12个数，求有多少种本质不同的填数方法，满足对图中六角星每条边的和都相等
    - <img src="https://s11.ax1x.com/2024/01/21/pFVn7G9.png" width="50%" height="50%">
- 思路：
    - 直接搜索，时间复杂度接近 $O(10^{12})$，是难以通过题目的
    - 不难观察到，每个数都会在两条边中出现
    - 我们设一条边的和为 $s$，所有数字的总和为 $sum$，则 $6 \times s = 2 \times sum$，故 $s = sum \div 3$
    - 借此我们可以进行搜索的剪枝，每填完一条边检验边和是否等于 $s$，即可通过本题

@@

## 一些注意事项
- 注意数据范围
    - 例如 E 题，$k$ 与 $a_{ij}$ 的数据范围都是 $[0,10^{18}]$，因此对这些数据的存储，输入输出，运算的过程都需要使用 `long long` 的数据类型
    - 同理，F 题在求和中也是超出了 `int` 的范围，同样需要使用 `long long`，这道题不少同学在此失分
- 一些不必要的语句
    - `inline`/`register` 都是曾经较为流行的卡常技巧，但在 O2 优化下，`inline` 指令会被编译器忽视；从 C++11 开始，编译器会忽视 `register` ，并且从 C++17 开始 `register` 这个关键字被取消，因此不建议大家使用这两个关键字
    - `system("pause")` 在本地一些编译器下，该命令可以使得编译的程序在输出完结果后可以保留窗口，方便调试，但是建议在提交代码时删去

            </script></section>
        </div>
    </div>
    <script src="https://accrobin.github.io/additional_files/reveal/reveal.js"></script>
    <script src="https://accrobin.github.io/additional_files/reveal/plugin/markdown/markdown.js"></script>
    <script src="https://accrobin.github.io/additional_files/reveal/plugin/highlight/highlight.js"></script>
    <script src="https://accrobin.github.io/additional_files/reveal/plugin/notes/notes.js"></script>
    <script src="https://accrobin.github.io/additional_files/reveal/plugin/math/math.js"></script>
    <script>
        Reveal.initialize({
            width: 1024,
            height: 800,
            slideNumber: 'c/t',
            vertical: false,
            // display: 'block',
            // margin: 0.04,
            // embedded: true,
            center: false,
            // transition: 'linear',
            // backgroundTransition: 'slide'
            // hash: true,
            // controls: true,
            // progress: true,
            // history: true,
            // center: true,
            katex: {
                version: 'latest',
                delimiters: [
                    {left: '$$', right: '$$', display: true},
                    {left: '$', right: '$', display: false},
                    {left: '\\(', right: '\\)', display: false},
                    {left: '\\[', right: '\\]', display: true}
                ],
                ignoredTags: ['script', 'noscript', 'style', 'textarea', 'pre']
            },
            plugins: [ RevealMath.KaTeX, RevealMarkdown, RevealHighlight, RevealNotes ]
        });
    </script>
</body>
</html>