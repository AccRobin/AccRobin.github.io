<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    
    <link rel="stylesheet" href="https://accrobin.github.io/additional_files/reveal/reveal.css">
    <link rel="stylesheet" href="https://accrobin.github.io/additional_files/reveal/plugin/highlight/monokai.css">
    <link rel="stylesheet" href="https://accrobin.github.io/additional_files/reveal/theme/white.css" id="theme">    
    
    <title>搜索与剪枝</title>
</head>

<body>
    <div class="reveal">
        <div class="slides">
            <section data-markdown data-separator-vertical="@@"><script type="text/template">
                # 搜索与剪枝

                @@
                
                ## 搜索与剪枝
                
                - 大部分问题不像排序一样存在高效且准确的算法
                    - [NP-complete](https://en.wikipedia.org/wiki/NP-completeness)：目前不存在多项式解法的问题（著名的千禧年七大数学难题之 [P=NP](https://en.wikipedia.org/wiki/P_versus_NP_problem)）
                    
                    - 甚至很难有优秀的近似算法：[Khot, Minzer & Safra, 2017] 对于任意 $\epsilon>0$，一个多项式时间复杂度的 $(\sqrt 2-\epsilon)$-近似算法的存在意味着 P=NP.
                
                不难见其重要性：是~~宇宙万法的本源~~诸多算法的基础，其内蕴含对程序深刻的认识和解决困难问题的思路
                
                许多算法跑得很快但复杂度难以严格证明（玄学优化），导致现在出题趋势逐渐远离搜索和剪枝
                
                可以不玄，但不可以不会
                
                ---
                # 深度优先搜索（Depth First Search）
                @@
                
                ## 深度优先搜索（DFS）
                
                - 深度优先：每次都尝试向更深的节点走
                - 特征：递归调用自身 & 保证每个点只访问一次
                - 复杂度：总状态数（点数）+ 总转移数（边数）
                
                @@
                
                ## 递归实例：斐波那契数
                > 给出斐波那契数列第 $n$ 项 $f(n)$ 的定义：
                > `$$
                f(n)=\begin{cases}
                1 & n=1,2\\
                f(n-1)+f(n-2) & n\ge 3
                \end{cases}
                > $$`
                > 输入 $n$，求 $f(n)$
                
                - 通俗的递归：函数自己调用自己
                
                ```cpp
                int f(int n) {
                    if (n == 1 || n == 2) return 1;
                    return f(n - 1) + f(n - 2);
                }
                ```
                
                状态机视角理解函数（甚至程序）[Model Checking](https://en.wikipedia.org/wiki/Model_checking)
                
                @@
                
                ## DFS 实例：八皇后问题
                
                > 输入正整数 $n$，输出 $n\times n$ 的棋盘上至多放多少个互不攻击的皇后（及方案数）
                
                - 状态：棋盘上哪些位置放置了皇后
                - 转移：新放置一个皇后
                - 合法状态：皇后互不攻击
                - 最终方案：深度最大的合法状态
                
                [$n=4$ 就跑不出答案了](https://pastes.io/47ihd7fomi)，有无意义的时间消耗：
                - 多次访问同一个状态
                - 访问不合法的状态及其后继
                
                剪枝：优化搜索的时间复杂度（或常数）
                
                @@
                
                ## 剪枝 1：记忆化搜索
                
                - 重复经过某个状态是多余的：当某个状态已经访问过就不再访问
                
                斐波那契数：记录数组 `a[i]` 表示 $f(i)$，非零则直接返回
                
                ```cpp
                int f(int n) {
                    if (n == 1 || n == 2) return 1;
                    if (a[n]) return a[n];
                    return a[n] = f(n - 1) + f(n - 2);
                }
                ```
                
                复杂度：指数 $\to$ 线性
                
                八皇后问题：有重复访问但难以记忆化
                
                - 保证转移不会导向重复状态
                
                八皇后问题：保证新放置的皇后位置更靠后（不重不漏）
                
                [可喜可贺，已经能跑出来 $n=5$ 了](https://pastes.io/j4al2a4utp)
                
                @@
                
                ## 剪枝 2：可行性剪枝
                
                - 不合法状态的后继也不合法：当某个状态已经不合法时直接抛弃
                
                八皇后问题：`else return;`
                
                [加上小小一句就能跑到 $n=9$](https://pastes.io/rfctafbjme)
                
                - 保证转移合法
                
                八皇后问题：保证新放置的皇后与之前皇后不会互相攻击
                
                [成功提高到 $n=10$](https://pastes.io/z9jxfwmows)
                
                @@
                
                ## 剪枝++：人类智慧型剪枝
                
                - 精细化合法状态的转移
                    - 每行至多一个皇后，依次选择每行皇后的位置，有意义的转移数 $O(n^2)\to O(n)$
                - `check` 复杂度较高
                    - 对每行，每列，每斜线建立数组，表示是否被占据，复杂度改进至 $O(1)$
                - ······
                
                最终能够满足 $n\le 13$ 甚至更高：[link](https://www.luogu.com.cn/problem/P1219)
                
                ---
                
                # 广度优先搜索（Breadth First Search）
                
                @@
                
                ## 广度优先搜索（BFS）
                
                - 广度优先：每次尝试访问同一层
                - 复杂度：总状态数（点数）+ 总转移数（边数）
                - 性质：BFS 找到的路径是从起点开始的最短合法路径
                
                @@
                
                ## BFS 的实现
                借助队列（先进先出）的性质：
                ```cpp
                queue<T> q;
                q.emplace(s); // s 是初始状态
                vis[s] = true; // 是否访问过（记忆化）
                d[s] = 0; // 深度
                while (q.size()) {
                    T u = q.front(); // 取出队列内第一个元素
                    q.pop();
                    for(T v : suf[u]) {
                        if (!vis[v]) {
                            q.push(v);
                            vis[v] = true;
                            d[v] = d[u] + 1;
                        }
                    }
                }
                ```
                
                @@
                
                ## BFS 本质：无权图单源最短路
                
                基于 BFS 总是给出最短路径这一性质，可以将其直接应用于求无权图上的单源最短路
                
                > 变式：无向无权图上有 $k$ 个关键点，求每个点到这 $k$ 个关键点的最小距离
                
                一开始把这 $k$ 个关键点都放入队列（单源本质就是 $k=1$ 时的特殊情况）
                
                大多数 BFS 的题目都可以转化为求某个（抽象意义上的）无权图单源最短路
                
                @@
                
                ## BFS 实例：走迷宫
                
                > 给出一个 $n\times n$ 的矩阵 $A$，$A_{i,j}$ 表示第 $i$ 行第 $j$ 列是否为障碍物。可以向相邻四个方向的任意一个方向走一步，在不超出矩阵且不跨越障碍的前提下，问从 $(1,1)$ 走到 $(n,n)$ 至少多少步
                
                以每个非障碍的格子为点，向四个方向的格子（如果有的话）连边，那么题目所求本质上就是点 $(1,1)$ 到点 $(n,n)$ 的最短路
                
                枚举四个方向：
                ```cpp
                int dx[] = {0, 1, 0, -1};
                int dy[] = {1, 0, -1, 0};
                for (int i = 0; i < 4; ++i) {
                    //(x, y) -> (x + dx[i], y + dy[i])
                }
                ```
                
                @@
                
                ## BFS 扩展：01 BFS
                
                > 给定一张边权为 $0$ 或 $1$ 的无向图，求单源最短路
                
                使用双端队列 `deque`，由边权为 $0$ 的边扩展得到的点放入队首，由边权为 $1$ 的边扩展得到的点放入队尾
            </script></section>
        </div>
    </div>
    <script src="https://accrobin.github.io/additional_files/reveal/reveal.js"></script>
    <script src="https://accrobin.github.io/additional_files/reveal/plugin/markdown/markdown.js"></script>
    <script src="https://accrobin.github.io/additional_files/reveal/plugin/highlight/highlight.js"></script>
    <script src="https://accrobin.github.io/additional_files/reveal/plugin/notes/notes.js"></script>
    <script src="https://accrobin.github.io/additional_files/reveal/plugin/math/math.js"></script>
    <script>
        Reveal.initialize({
            width: 1024,
            height: 768,
            slideNumber: 'c/t',
            vertical: false,
            // display: 'block',
            // margin: 0.04,
            // embedded: true,
            center: false,
            // transition: 'linear',
            // backgroundTransition: 'slide'
            // hash: true,
            // controls: true,
            // progress: true,
            // history: true,
            // center: true,
            katex: {
                version: 'latest',
                delimiters: [
                    {left: '$$', right: '$$', display: true},
                    {left: '$', right: '$', display: false},
                    {left: '\\(', right: '\\)', display: false},
                    {left: '\\[', right: '\\]', display: true}
                ],
                ignoredTags: ['script', 'noscript', 'style', 'textarea', 'pre']
            },
            plugins: [ RevealMath.KaTeX, RevealMarkdown, RevealHighlight, RevealNotes ]
        });
    </script>
</body>
</html>