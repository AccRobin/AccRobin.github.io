# 搜索与剪枝

@@

## 搜索与剪枝

- 大部分问题不像排序一样存在高效且准确的算法
    - [NP-complete](https://en.wikipedia.org/wiki/NP-completeness)：目前不存在多项式解法的问题（[P=NP](https://en.wikipedia.org/wiki/P_versus_NP_problem)）
    
    - 甚至很难有优秀的近似算法：[Khot, Minzer & Safra, 2017] 对于任意 $\epsilon>0$，一个多项式时间复杂度的 $(\sqrt 2-\epsilon)$-近似算法的存在意味着 P=NP.

不难见其重要性：是~~宇宙万法的本源~~诸多算法的基础，其内蕴含对程序深刻的认识和解决困难问题的思路

许多算法跑得很快但复杂度难以严格证明（玄学优化），导致现在出题趋势逐渐远离搜索和剪枝

可以不玄，但不可以不会

---
# 深度优先搜索（Depth First Search）
@@

## 深度优先搜索（DFS）

- 深度优先：每次都尝试向更深的节点走
- 特征：递归调用自身 & 保证每个点只访问一次
- 复杂度：总状态数（点数）+ 总转移数（边数）

@@

## 递归实例：斐波那契数
> 给出斐波那契数列第 $n$ 项 $f(n)$ 的定义：
> `$$
f(n)=\begin{cases}
1 & n=1,2\\
f(n-1)+f(n-2) & n\ge 3
\end{cases}
> $$`
> 输入 $n$，求 $f(n)$

- 通俗的递归：函数自己调用自己

```cpp
int f(int n) {
    if (n == 1 || n == 2) return 1;
    return f(n - 1) + f(n - 2);
}
```

状态机视角理解函数（甚至程序）[Model Checking](https://en.wikipedia.org/wiki/Model_checking)

@@

## DFS 实例：八皇后问题

> 输入正整数 $n$，输出 $n\times n$ 的棋盘上至多放多少个互不攻击的皇后（及方案数）

- 状态：棋盘上哪些位置放置了皇后
- 转移：新放置一个皇后
- 合法状态：皇后互不攻击
- 最终方案：深度最大的合法状态

[$n=4$ 就跑不出答案了](https://pastes.io/47ihd7fomi)，有无意义的时间消耗：
- 多次访问同一个状态
- 访问不合法的状态及其后继

剪枝：优化搜索的时间复杂度（或常数）

@@

## 剪枝 1：记忆化搜索

- 重复经过某个状态是多余的：当某个状态已经访问过就不再访问

斐波那契数：记录数组 `a[i]` 表示 $f(i)$，非零则直接返回

```cpp
int f(int n) {
    if (n == 1 || n == 2) return 1;
    if (a[n]) return a[n];
    return a[n] = f(n - 1) + f(n - 2);
}
```

复杂度：指数 $\to$ 线性

八皇后问题：有重复访问但难以记忆化

- 保证转移不会导向重复状态

八皇后问题：保证新放置的皇后位置更靠后（不重不漏）

[可喜可贺，已经能跑出来 $n=5$ 了](https://pastes.io/j4al2a4utp)

@@

## 剪枝 2：可行性剪枝

- 不合法状态的后继也不合法：当某个状态已经不合法时直接抛弃

八皇后问题：`else return;`

[加上小小一句就能跑到 $n=9$](https://pastes.io/rfctafbjme)

- 保证转移合法

八皇后问题：保证新放置的皇后与之前皇后不会互相攻击

[成功提高到 $n=10$](https://pastes.io/z9jxfwmows)

@@

## 剪枝++：人类智慧型剪枝

- 精细化合法状态的转移
    - 每行至多一个皇后，依次选择每行皇后的位置，有意义的转移数 $O(n^2)\to O(n)$
- `check` 复杂度较高
    - 对每行，每列，每斜线建立数组，表示是否被占据，复杂度改进至 $O(1)$
- ······

最终能够满足 $n\le 13$ 甚至更高：[link](https://www.luogu.com.cn/problem/P1219)

---

# 广度优先搜索（Breadth First Search）

@@

## 广度优先搜索（BFS）

- 广度优先：每次尝试访问同一层
- 复杂度：总状态数（点数）+ 总转移数（边数）
- 性质：BFS 找到的路径是从起点开始的最短合法路径

@@

## BFS 的实现
借助队列（先进先出）的性质：
```cpp
queue<T> q;
q.emplace(s); // s 是初始状态
vis[s] = true; // 是否访问过（记忆化）
d[s] = 0; // 深度
while (q.size()) {
    T u = q.front(); // 取出队列内第一个元素
    q.pop();
    for(T v : suf[u]) {
        if (!vis[v]) {
            q.push(v);
            vis[v] = true;
            d[v] = d[u] + 1;
        }
    }
}
```

@@

## BFS 本质：无权图单源最短路

基于 BFS 总是给出最短路径这一性质，可以将其直接应用于求无权图上的单源最短路

> 变式：无向无权图上有 $k$ 个关键点，求每个点到这 $k$ 个关键点的最小距离

一开始把这 $k$ 个关键点都放入队列（单源本质就是 $k=1$ 时的特殊情况）

大多数 BFS 的题目都可以转化为求某个（抽象意义上的）无权图单源最短路

@@

## BFS 实例：走迷宫

> 给出一个 $n\times n$ 的矩阵 $A$，$A_{i,j}$ 表示第 $i$ 行第 $j$ 列是否为障碍物。可以向相邻四个方向的任意一个方向走一步，在不超出矩阵且不跨越障碍的前提下，问从 $(1,1)$ 走到 $(n,n)$ 至少多少步

以每个非障碍的格子为点，向四个方向的格子（如果有的话）连边，那么题目所求本质上就是点 $(1,1)$ 到点 $(n,n)$ 的最短路

- 小 trick：枚举四个方向
```cpp
int dx[] = {0, 1, 0, -1};
int dy[] = {1, 0, -1, 0};
for (int i = 0; i < 4; ++i) {
    //(x, y) -> (x + dx[i], y + dy[i])
}
```

@@

## BFS 扩展：01 BFS

> 给定一张边权为 $0$ 或 $1$ 的无向图，求单源最短路

使用双端队列 `deque`，由边权为 $0$ 的边扩展得到的点放入队首，由边权为 $1$ 的边扩展得到的点放入队尾

正确性来源于 BFS 的分层结构：边只会出现在同一层内部或相邻两层之间

例题：[P4554](https://www.luogu.com.cn/problem/P4554)

---

# 双向搜索/折半搜索（Meet in the middle）

@@

## Meet in the middle

- 想要得到起点 $s$ 到目标 $t$ 的所有路径的某些信息（最短路径，路径数目等），但是直接搜索复杂度较高
    - 双向搜索：考虑从 $s$ 出发搜索一部分，从 $t$ 出发搜索一部分，将这两部分信息进行快速合并
- 直接搜索代价过大
    - 将问题分为两部分分别处理，再高效合并

@@

## Meet in the middle 实例：[CF888E](https://codeforces.com/contest/888/problem/E)

> 给定一个序列 $a_1, a_2, \cdots, a_n$ 和正整数 $m$，你可以选出一个子能序列 $a_{b_1}, a_{b_2}, \cdots, a_{b_k}(1\le b_1<b_2<\cdots<b_k\le n)$，你需要最大化这个子序列的和模 $m$ 的值，即
> $$
\left(\sum_{i=1}^k a_{b_i}\right)\bmod m
> $$
> 其中 $n\le 35, a_i, m\le 10^9$

从长为 $n$ 的序列中选出一个子列的方案数为 $2^n$，是不能够接受的

@@

## Meet in the middle 实例：[CF888E](https://codeforces.com/contest/888/problem/E)

- 将 $a$ 分为尽可能一样多的两部分，分别算出这两部分所有的子序列和模 $m$，记为 $x_1,\cdots, x_p$ 和 $y_1,\cdots, y_q$，这一部分复杂度为 $O(2^{\frac n2})$，可以接受

- 问题转化为了：从 $x$ 中选出一个数 $t$，从 $y$ 中选出一个数 $s$，使得 $s+t\bmod m$ 最大

- $p,q$ 都是 $O(2^{\frac n2})$ 级别，直接两两合并就是 $O(2^n)$，与暴力没区别

- 对于序列 $x$ 中的每一个元素 $t$，与 $t$ 可能作为最大值的只有 $y$ 中小于 $m-t$ 的最大数（前驱）和 $y$ 中的最大数

- 对 $x$ 和 $y$ 分别排序，使用二分（或双指针）可以解决

- 事实上，更进一步地，第二种情况只会发生在 $\max x+\max y$ 上
